"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTreeItem2 = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _extractEventHandlers = _interopRequireDefault(require("@mui/utils/extractEventHandlers"));
var _useForkRef = _interopRequireDefault(require("@mui/utils/useForkRef"));
var _TreeViewProvider = require("../internals/TreeViewProvider");
var _useTreeItem2Utils = require("../hooks/useTreeItem2Utils");
var _TreeViewItemDepthContext = require("../internals/TreeViewItemDepthContext");
var _tree = require("../internals/utils/tree");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const useTreeItem2 = parameters => {
  const {
    runItemPlugins,
    items: {
      onItemClick,
      disabledItemsFocusable,
      indentationAtItemLevel
    },
    selection: {
      multiSelect,
      disableSelection,
      checkboxSelection
    },
    expansion: {
      expansionTrigger
    },
    instance,
    publicAPI
  } = (0, _TreeViewProvider.useTreeViewContext)();
  const depthContext = React.useContext(_TreeViewItemDepthContext.TreeViewItemDepthContext);
  const {
    id,
    itemId,
    label,
    children,
    rootRef
  } = parameters;
  const {
    rootRef: pluginRootRef,
    contentRef,
    propsEnhancers
  } = runItemPlugins(parameters);
  const {
    interactions,
    status
  } = (0, _useTreeItem2Utils.useTreeItem2Utils)({
    itemId,
    children
  });
  const rootRefObject = React.useRef(null);
  const contentRefObject = React.useRef(null);
  const idAttribute = instance.getTreeItemIdAttribute(itemId, id);
  const handleRootRef = (0, _useForkRef.default)(rootRef, pluginRootRef, rootRefObject);
  const handleContentRef = (0, _useForkRef.default)(contentRef, contentRefObject);
  const checkboxRef = React.useRef(null);
  const rootTabIndex = instance.canItemBeTabbed(itemId) ? 0 : -1;
  const createRootHandleFocus = otherHandlers => event => {
    otherHandlers.onFocus?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const canBeFocused = !status.disabled || disabledItemsFocusable;
    if (!status.focused && canBeFocused && event.currentTarget === event.target) {
      instance.focusItem(event, itemId);
    }
  };
  const createRootHandleBlur = otherHandlers => event => {
    otherHandlers.onBlur?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const rootElement = instance.getItemDOMElement(itemId);

    // Don't blur the root when switching to editing mode
    // the input that triggers the root blur can be either the relatedTarget (when entering editing state) or the target (when exiting editing state)
    // when we enter the editing state, we focus the input -> we don't want to remove the focused item from the state
    if (status.editing ||
    // we can exit the editing state by clicking outside the input (within the tree item) or by pressing Enter or Escape -> we don't want to remove the focused item from the state in these cases
    // we can also exit the editing state by clicking on the root itself -> want to remove the focused item from the state in this case
    event.relatedTarget && (0, _tree.isTargetInDescendants)(event.relatedTarget, rootElement) && (event.target && event.target?.dataset?.element === 'labelInput' && (0, _tree.isTargetInDescendants)(event.target, rootElement) || event.relatedTarget?.dataset?.element === 'labelInput')) {
      return;
    }
    instance.removeFocusedItem();
  };
  const createRootHandleKeyDown = otherHandlers => event => {
    otherHandlers.onKeyDown?.(event);
    if (event.defaultMuiPrevented || event.target?.dataset?.element === 'labelInput') {
      return;
    }
    instance.handleItemKeyDown(event, itemId);
  };
  const createLabelHandleDoubleClick = otherHandlers => event => {
    otherHandlers.onDoubleClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    interactions.toggleItemEditing();
  };
  const createContentHandleClick = otherHandlers => event => {
    otherHandlers.onClick?.(event);
    onItemClick?.(event, itemId);
    if (event.defaultMuiPrevented || checkboxRef.current?.contains(event.target)) {
      return;
    }
    if (expansionTrigger === 'content') {
      interactions.handleExpansion(event);
    }
    if (!checkboxSelection) {
      interactions.handleSelection(event);
    }
  };
  const createContentHandleMouseDown = otherHandlers => event => {
    otherHandlers.onMouseDown?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }

    // Prevent text selection
    if (event.shiftKey || event.ctrlKey || event.metaKey || status.disabled) {
      event.preventDefault();
    }
  };
  const createCheckboxHandleChange = otherHandlers => event => {
    otherHandlers.onChange?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (disableSelection || status.disabled) {
      return;
    }
    interactions.handleCheckboxSelection(event);
  };
  const createInputHandleKeydown = otherHandlers => event => {
    otherHandlers.onKeyDown?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const target = event.target;
    if (event.key === 'Enter' && target.value) {
      interactions.handleSaveItemLabel(event, target.value);
    } else if (event.key === 'Escape') {
      interactions.handleCancelItemLabelEditing(event);
    }
  };
  const createInputHandleBlur = otherHandlers => event => {
    otherHandlers.onBlur?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.target.value) {
      interactions.handleSaveItemLabel(event, event.target.value);
    }
  };
  const createIconContainerHandleClick = otherHandlers => event => {
    otherHandlers.onClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (expansionTrigger === 'iconContainer') {
      interactions.handleExpansion(event);
    }
  };
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extends2.default)({}, (0, _extractEventHandlers.default)(parameters), (0, _extractEventHandlers.default)(externalProps));
    let ariaSelected;
    if (multiSelect) {
      ariaSelected = status.selected;
    } else if (status.selected) {
      /* single-selection trees unset aria-selected on un-selected items.
       *
       * If the tree does not support multiple selection, aria-selected
       * is set to true for the selected item and it is not present on any other item in the tree.
       * Source: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/
       */
      ariaSelected = true;
    }
    const props = (0, _extends2.default)({}, externalEventHandlers, {
      ref: handleRootRef,
      role: 'treeitem',
      tabIndex: rootTabIndex,
      id: idAttribute,
      'aria-expanded': status.expandable ? status.expanded : undefined,
      'aria-selected': ariaSelected,
      'aria-disabled': status.disabled || undefined
    }, externalProps, {
      onFocus: createRootHandleFocus(externalEventHandlers),
      onBlur: createRootHandleBlur(externalEventHandlers),
      onKeyDown: createRootHandleKeyDown(externalEventHandlers)
    });
    if (indentationAtItemLevel) {
      props.style = {
        '--TreeView-itemDepth': typeof depthContext === 'function' ? depthContext(itemId) : depthContext
      };
    }
    const enhancedRootProps = propsEnhancers.root?.({
      rootRefObject,
      contentRefObject,
      externalEventHandlers
    }) ?? {};
    return (0, _extends2.default)({}, props, enhancedRootProps);
  };
  const getContentProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extractEventHandlers.default)(externalProps);
    const props = (0, _extends2.default)({}, externalEventHandlers, externalProps, {
      ref: handleContentRef,
      onClick: createContentHandleClick(externalEventHandlers),
      onMouseDown: createContentHandleMouseDown(externalEventHandlers),
      status
    });
    if (indentationAtItemLevel) {
      props.indentationAtItemLevel = true;
    }
    const enhancedContentProps = propsEnhancers.content?.({
      rootRefObject,
      contentRefObject,
      externalEventHandlers
    }) ?? {};
    return (0, _extends2.default)({}, props, enhancedContentProps);
  };
  const getCheckboxProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extractEventHandlers.default)(externalProps);
    return (0, _extends2.default)({}, externalEventHandlers, {
      visible: checkboxSelection,
      ref: checkboxRef,
      checked: status.selected,
      disabled: disableSelection || status.disabled,
      tabIndex: -1
    }, externalProps, {
      onChange: createCheckboxHandleChange(externalEventHandlers)
    });
  };
  const getLabelProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extends2.default)({}, (0, _extractEventHandlers.default)(externalProps));
    const props = (0, _extends2.default)({}, externalEventHandlers, {
      children: label
    }, externalProps, {
      onDoubleClick: createLabelHandleDoubleClick(externalEventHandlers)
    });
    if (instance.isTreeViewEditable) {
      props.editable = status.editable;
    }
    return props;
  };
  const getLabelInputProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extractEventHandlers.default)(externalProps);
    const props = (0, _extends2.default)({}, externalEventHandlers, externalProps, {
      onKeyDown: createInputHandleKeydown(externalEventHandlers),
      onBlur: createInputHandleBlur(externalEventHandlers)
    });
    const enhancedlabelInputProps = propsEnhancers.labelInput?.({
      rootRefObject,
      contentRefObject,
      externalEventHandlers
    }) ?? {};
    return (0, _extends2.default)({}, props, enhancedlabelInputProps);
  };
  const getIconContainerProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extractEventHandlers.default)(externalProps);
    return (0, _extends2.default)({}, externalEventHandlers, externalProps, {
      onClick: createIconContainerHandleClick(externalEventHandlers)
    });
  };
  const getGroupTransitionProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extractEventHandlers.default)(externalProps);
    const response = (0, _extends2.default)({}, externalEventHandlers, {
      unmountOnExit: true,
      component: 'ul',
      role: 'group',
      in: status.expanded,
      children
    }, externalProps);
    if (indentationAtItemLevel) {
      response.indentationAtItemLevel = true;
    }
    return response;
  };
  const getDragAndDropOverlayProps = (externalProps = {}) => {
    const externalEventHandlers = (0, _extends2.default)({}, (0, _extractEventHandlers.default)(externalProps));
    const enhancedDragAndDropOverlayProps = propsEnhancers.dragAndDropOverlay?.({
      rootRefObject,
      contentRefObject,
      externalEventHandlers
    }) ?? {};
    return (0, _extends2.default)({}, externalProps, enhancedDragAndDropOverlayProps);
  };
  return {
    getRootProps,
    getContentProps,
    getGroupTransitionProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    rootRef: handleRootRef,
    status,
    publicAPI
  };
};
exports.useTreeItem2 = useTreeItem2;